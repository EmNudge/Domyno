"use strict";function o(o,e=(o=>Boolean(o))){for(const t of o)if(e(t))return!0;return!1}function e(o,e=(o=>Boolean(o))){for(const t of o)if(!e(t))return!1;return!0}function t(o,e){for(const t of o){if("function"==typeof e?e(t):e===t)return!0}return!1}function n(o,e){for(const t of o){if("function"==typeof e?e(t):e===t)return t}return null}function r(o,e,t){let n=e;for(const e of o)n=t(n,e);return n}function*f(o){let e=0;for(const t of o)yield[e,t],e++}function*i(o,e){for(const[t,n]of f(o))yield e(n,t)}function*p(o,e){for(const[t,n]of f(o))e(n,t)&&(yield n)}function*c(o){for(const e of o)for(const o of e)yield o}function*u(o,e){yield*c(i(o,e))}Object.defineProperty(exports,"__esModule",{value:!0});exports.chain=function*(...o){yield*c(o)},exports.collect=o=>[...o],exports.contains=t,exports.cycle=function*(o){for(;;)for(const e of o)yield e},exports.entries=f,exports.every=e,exports.filter=p,exports.find=n,exports.flat=c,exports.flatMap=u,exports.iterableFromNested=function*(o,e){let t=o;for(;t;)yield t,t=t[e]},exports.map=i,exports.pipe=(...o)=>e=>o.reduce((o,e)=>e(o),e),exports.pipeContains=function(o){return e=>t(e,o)},exports.pipeEvery=function(o){return t=>e(t,o)},exports.pipeFilter=function(o){return e=>p(e,o)},exports.pipeFind=function(o){return e=>n(e,o)},exports.pipeFlatMap=function(o){return e=>u(e,o)},exports.pipeMap=function(o){return e=>i(e,o)},exports.pipeReduce=function(o,e){return t=>r(t,o,e)},exports.pipeSome=function(e){return t=>o(t,e)},exports.reduce=r,exports.slice=function*(o,e,t){for(const[n,r]of f(o))n<e||t&&t>t||(yield r)},exports.some=o,exports.take=function*(o,e){for(const[t,n]of f(o)){if(t===e)return;yield n}},exports.takeWhile=function*(o,e){for(const[t,n]of f(o)){if(!e(n,t))return;yield n}},exports.zip=function*(...o){const e=o.map(o=>o[Symbol.iterator]()),t=e.map(o=>o.next());for(;t.every(o=>!o.done);){yield t.map(o=>o.value);for(let o=0;o<t.length;o++)t[o]=e[o].next()}};
