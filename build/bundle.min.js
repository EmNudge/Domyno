"use strict";function*t(t){let n=0;for(const o of t)yield[n,o],n++}function*n(t){for(const n of t)for(const t of n)yield t}function o(n){return function*(o){for(const[r,e]of t(o))yield n(e,r)}}Object.defineProperty(exports,"__esModule",{value:!0});exports.chain=function*(...t){yield*n(t)},exports.chunk=function(t){return function*(n){const o=[];for(const r of n)o.length===t&&(yield o,o.length=0),o.push(r);o.length&&(yield o)}},exports.collect=t=>[...t],exports.contains=function(t){return n=>{for(const o of n){if("function"==typeof t?t(o):t===o)return!0}return!1}},exports.cycle=function*(t){for(;;)for(const n of t)yield n},exports.entries=function*(t){const n=Object.keys(t);for(const o of n)yield[o,t[o]]},exports.enumerate=t,exports.every=function(t=(t=>Boolean(t))){return n=>{for(const o of n)if(!t(o))return!1;return!0}},exports.filter=function(n){return function*(o){for(const[r,e]of t(o))n(e,r)&&(yield e)}},exports.find=function(t){return n=>{for(const o of n){if("function"==typeof t?t(o):t===o)return o}return null}},exports.flat=n,exports.flatMap=function(t){return function*(r){yield*n(o(t)(r))}},exports.iterableFromNested=function(t){return function*(n){let o=n;for(;o;)yield o,o=o[t]}},exports.map=o,exports.nth=function(n){return o=>{if(n<0)throw new Error("index for nth cannot be negative");for(const[r,e]of t(o))if(n==r)return e;return null}},exports.partition=function(t){return n=>{const o=[],r=[];for(const e of n)t(e)?o.push(e):r.push(e);return[o,r]}},exports.pipe=function(...t){return n=>t.reduce((t,n)=>n(t),n)},exports.reduce=function(t,n){return o=>{let r=t;for(const t of o)r=n(r,t);return r}},exports.slice=function(n,o){return function*(r){for(const[e,f]of t(r))e<n||o&&o>o||(yield f)}},exports.some=function(t=(t=>Boolean(t))){return n=>{for(const o of n)if(t(o))return!0;return!1}},exports.tail=function(t){let n=null;for(const o of t)n=o;return n},exports.take=function(n){return function*(o){for(const[r,e]of t(o)){if(r===n)return;yield e}}},exports.takeWhile=function(n){return function*(o){for(const[r,e]of t(o)){if(!n(e,r))return;yield e}}},exports.tap=function(t){return function*(n){yield*o(n=>(t(n),n))(n)}},exports.unzip=function(t){const n=[],o=[];for(const[r,e]of t)n.push(r),o.push(e);return[n,o]},exports.zip=function*(...t){const n=t.map(t=>t[Symbol.iterator]());let o=n.map(t=>t.next());for(;o.every(t=>!t.done);)yield o.map(t=>t.value),o=n.map(t=>t.next())};
